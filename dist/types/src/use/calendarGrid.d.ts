import { ExtractPropTypes, PropType } from 'vue';
import { CalendarDay } from '../utils/page';
import { EventConfig, Event } from '../utils/calendar/event';
import { DateRange, DateRangeContext } from '../utils/date/range';
export declare type GridStateEvent = 'GRID_CURSOR_DOWN' | 'GRID_CURSOR_DOWN_SHIFT' | 'GRID_CURSOR_MOVE' | 'GRID_CURSOR_MOVE_SHIFT' | 'GRID_CURSOR_UP' | 'GRID_CURSOR_UP_SHIFT' | 'EVENT_CURSOR_DOWN' | 'EVENT_CURSOR_DOWN_SHIFT' | 'EVENT_CURSOR_MOVE' | 'EVENT_CURSOR_MOVE_SHIFT' | 'EVENT_RESIZE_START_CURSOR_DOWN' | 'EVENT_RESIZE_START_CURSOR_DOWN_SHIFT' | 'EVENT_RESIZE_END_CURSOR_DOWN' | 'EVENT_RESIZE_END_CURSOR_DOWN_SHIFT' | 'ESCAPE';
export interface Point {
    x: number;
    y: number;
}
export interface DragOffset {
    weekdays: number;
    weeks: number;
    ms: number;
}
export interface ResizeOffset {
    weekdays: number;
    weeks: number;
    ms: number;
}
export interface DragOriginState {
    position: number;
    date: Date;
    day: CalendarDay;
    event: Event;
    eventSelected: boolean;
    ms: number;
}
export interface ResizeOriginState {
    position: number;
    day: CalendarDay;
    event: Event;
    isWeekly: boolean;
    isStart: boolean;
    isNew: boolean;
    ms: number;
}
export interface CreateOriginState {
    position: number;
    date: Date;
    day: CalendarDay;
    isWeekly: boolean;
}
export declare const emits: string[];
export declare const propsDef: {
    events: {
        type: PropType<EventConfig[]>;
        default: () => never[];
    };
    view: {
        type: PropType<import("./calendar").CalendarView>;
        default: string;
        validator(value: string): boolean;
    };
    rows: {
        type: NumberConstructor;
        default: number;
    };
    columns: {
        type: NumberConstructor;
        default: number;
    };
    step: NumberConstructor;
    titlePosition: {
        type: PropType<import("../utils/page").TitlePosition>;
        default: () => import("../utils/page").TitlePosition;
    };
    navVisibility: {
        type: PropType<import("../utils/popovers").PopoverVisibility>;
        default: () => import("../utils/popovers").PopoverVisibility;
    };
    showWeeknumbers: (BooleanConstructor | StringConstructor)[];
    showIsoWeeknumbers: (BooleanConstructor | StringConstructor)[];
    isExpanded: BooleanConstructor;
    initialPage: PropType<import("../utils/page").PageAddress>;
    initialPagePosition: {
        type: NumberConstructor;
        default: number;
    };
    minPage: PropType<import("../utils/page").PageAddress>;
    maxPage: PropType<import("../utils/page").PageAddress>;
    transition: PropType<import("./calendar").MoveTransition>;
    attributes: PropType<import("../utils/attribute").AttributeConfig[]>;
    trimWeeks: BooleanConstructor;
    disablePageSwipe: BooleanConstructor;
    buddhist: {
        type: BooleanConstructor;
        default: boolean;
    };
    color: {
        type: StringConstructor;
        default: () => any;
    };
    isDark: {
        type: PropType<boolean | "system" | import("vue-screen-utils").DarkModeClassConfig>;
        default: () => any;
    };
    firstDayOfWeek: PropType<import("../utils/date/helpers").DayOfWeek>;
    masks: ObjectConstructor;
    locale: PropType<string | Record<string, any> | import("../utils/locale").default>;
    timezone: StringConstructor;
    minDate: null;
    maxDate: null;
    disabledDates: null;
};
export declare type CalendarGridProps = Readonly<ExtractPropTypes<typeof propsDef>>;
export declare type CalendarGridContext = ReturnType<typeof createCalendarGrid>;
declare type IBoundingRect = Pick<Element, 'getBoundingClientRect' | 'contains'>;
export declare function createCalendarGrid(props: CalendarGridProps, { emit, slots }: any): {
    dailyGridRef: import("vue").Ref<{
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null, IBoundingRect | {
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null>;
    weeklyGridRef: import("vue").Ref<{
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null, IBoundingRect | {
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null>;
    cellPopoverRef: import("vue").Ref<import("vue").DefineComponent<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>, {
        displayMode: import("vue").ComputedRef<"light" | "dark">;
        color: import("vue").ComputedRef<string>;
        show: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        update: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        hide: () => void;
        isVisible: () => boolean;
        onAfterHide(): void;
        event: import("vue").Ref<{
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null, {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null>;
        popoverRef: import("vue").Ref<null, null>;
    }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>> & Readonly<{}>, {
        popoverId: string;
    }, {}, {
        Popover: import("vue").DefineComponent<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>, {
            popoverRef: import("vue").Ref<HTMLElement | undefined, HTMLElement | undefined>;
            alignment: import("vue").ComputedRef<"center" | "left" | "right" | "top" | "bottom" | "middle">;
            hide: (opts?: Partial<import("../utils/popovers").PopoverOptions>) => void;
            setupPopper: () => void;
            beforeEnter: (el: HTMLElement) => void;
            afterEnter: (el: HTMLElement) => void;
            beforeLeave: (el: HTMLElement) => void;
            afterLeave: (el: HTMLElement) => void;
            onClick: (e: MouseEvent) => void;
            onMouseOver: () => void;
            onMouseLeave: () => void;
            onFocusIn: () => void;
            onFocusOut: (e: FocusEvent) => void;
            isVisible: import("vue").Ref<boolean, boolean>;
            target: import("vue").Ref<unknown, unknown>;
            data: import("vue").Ref<any, any>;
            transition: import("vue").Ref<string, string>;
            placement: import("vue").Ref<import("@popperjs/core").Placement, import("@popperjs/core").Placement>;
            direction: import("vue").Ref<string, string>;
            positionFixed: import("vue").Ref<false, false>;
            modifiers: import("vue").Ref<any[], any[]>;
            isInteractive: import("vue").Ref<boolean, boolean>;
            visibility: import("vue").Ref<import("../utils/popovers").PopoverVisibility, import("../utils/popovers").PopoverVisibility>;
            isHovered: import("vue").Ref<boolean, boolean>;
            isFocused: import("vue").Ref<boolean, boolean>;
            autoHide: import("vue").Ref<boolean, boolean>;
            force: import("vue").Ref<boolean, boolean>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("before-show" | "after-show" | "before-hide" | "after-hide")[], "before-show" | "after-show" | "before-hide" | "after-hide", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>> & Readonly<{
            "onBefore-show"?: ((...args: any[]) => any) | undefined;
            "onAfter-show"?: ((...args: any[]) => any) | undefined;
            "onBefore-hide"?: ((...args: any[]) => any) | undefined;
            "onAfter-hide"?: ((...args: any[]) => any) | undefined;
        }>, {
            showDelay: number;
            hideDelay: number;
        }, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
        CalendarEventEdit: import("vue").DefineComponent<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>, {
            onRemove(): void;
            onToggleEditing(): void;
            onSave(): void;
            onCancel(): void;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "close"[], "close", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>> & Readonly<{
            onClose?: ((...args: any[]) => any) | undefined;
        }>, {}, {}, {}, {
            focus: {
                mounted(el: any): void;
            };
        }, string, import("vue").ComponentProvideOptions, true, {}, any>;
    }, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | undefined, import("vue").DefineComponent<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>, {
        displayMode: import("vue").ComputedRef<"light" | "dark">;
        color: import("vue").ComputedRef<string>;
        show: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        update: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        hide: () => void;
        isVisible: () => boolean;
        onAfterHide(): void;
        event: import("vue").Ref<{
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null, {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null>;
        popoverRef: import("vue").Ref<null, null>;
    }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>> & Readonly<{}>, {
        popoverId: string;
    }, {}, {
        Popover: import("vue").DefineComponent<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>, {
            popoverRef: import("vue").Ref<HTMLElement | undefined, HTMLElement | undefined>;
            alignment: import("vue").ComputedRef<"center" | "left" | "right" | "top" | "bottom" | "middle">;
            hide: (opts?: Partial<import("../utils/popovers").PopoverOptions>) => void;
            setupPopper: () => void;
            beforeEnter: (el: HTMLElement) => void;
            afterEnter: (el: HTMLElement) => void;
            beforeLeave: (el: HTMLElement) => void;
            afterLeave: (el: HTMLElement) => void;
            onClick: (e: MouseEvent) => void;
            onMouseOver: () => void;
            onMouseLeave: () => void;
            onFocusIn: () => void;
            onFocusOut: (e: FocusEvent) => void;
            isVisible: import("vue").Ref<boolean, boolean>;
            target: import("vue").Ref<unknown, unknown>;
            data: import("vue").Ref<any, any>;
            transition: import("vue").Ref<string, string>;
            placement: import("vue").Ref<import("@popperjs/core").Placement, import("@popperjs/core").Placement>;
            direction: import("vue").Ref<string, string>;
            positionFixed: import("vue").Ref<false, false>;
            modifiers: import("vue").Ref<any[], any[]>;
            isInteractive: import("vue").Ref<boolean, boolean>;
            visibility: import("vue").Ref<import("../utils/popovers").PopoverVisibility, import("../utils/popovers").PopoverVisibility>;
            isHovered: import("vue").Ref<boolean, boolean>;
            isFocused: import("vue").Ref<boolean, boolean>;
            autoHide: import("vue").Ref<boolean, boolean>;
            force: import("vue").Ref<boolean, boolean>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("before-show" | "after-show" | "before-hide" | "after-hide")[], "before-show" | "after-show" | "before-hide" | "after-hide", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>> & Readonly<{
            "onBefore-show"?: ((...args: any[]) => any) | undefined;
            "onAfter-show"?: ((...args: any[]) => any) | undefined;
            "onBefore-hide"?: ((...args: any[]) => any) | undefined;
            "onAfter-hide"?: ((...args: any[]) => any) | undefined;
        }>, {
            showDelay: number;
            hideDelay: number;
        }, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
        CalendarEventEdit: import("vue").DefineComponent<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>, {
            onRemove(): void;
            onToggleEditing(): void;
            onSave(): void;
            onCancel(): void;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "close"[], "close", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>> & Readonly<{
            onClose?: ((...args: any[]) => any) | undefined;
        }>, {}, {}, {}, {
            focus: {
                mounted(el: any): void;
            };
        }, string, import("vue").ComponentProvideOptions, true, {}, any>;
    }, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | undefined>;
    dayColumns: import("vue").ComputedRef<number>;
    dayRows: import("vue").ComputedRef<number>;
    snapMinutes: import("vue").Ref<number, number>;
    snapMs: import("vue").ComputedRef<number>;
    pixelsPerHour: import("vue").Ref<number, number>;
    isTouch: import("vue").Ref<boolean, boolean>;
    events: import("vue").ComputedRef<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }[]>;
    eventsMap: import("vue").Ref<Record<any, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }>, Record<any, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }>>;
    selectedEvents: import("vue").ComputedRef<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }[]>;
    hasSelectedEvents: import("vue").ComputedRef<boolean>;
    eventsContext: import("vue").ComputedRef<DateRangeContext>;
    detailEvent: import("vue").Ref<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: {
            order: number;
            locale: {
                id: any;
                daysInWeek: number;
                firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                masks: any;
                timezone: string | undefined;
                hourLabels: string[];
                dayNames: string[];
                dayNamesShort: string[];
                dayNamesShorter: string[];
                dayNamesNarrow: string[];
                monthNames: string[];
                monthNamesShort: string[];
                relativeTimeNames: {
                    year?: string | undefined;
                    years?: string | undefined;
                    quarter?: string | undefined;
                    quarters?: string | undefined;
                    month?: string | undefined;
                    months?: string | undefined;
                    week?: string | undefined;
                    weeks?: string | undefined;
                    day?: string | undefined;
                    days?: string | undefined;
                    hour?: string | undefined;
                    hours?: string | undefined;
                    minute?: string | undefined;
                    minutes?: string | undefined;
                    second?: string | undefined;
                    seconds?: string | undefined;
                };
                amPm: [string, string];
                monthCache: {
                    keys: string[];
                    store: Record<string, import("../utils/date/helpers").MonthParts>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                };
                pageCache: {
                    keys: string[];
                    store: Record<string, import("../utils/page").CachedPage>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/page").CachedPage;
                    get: (...args: any[]) => import("../utils/page").CachedPage;
                    getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                };
                formatDate: (date: Date, masks: string | string[]) => string;
                parseDate: (dateString: string, mask: string | string[]) => Date;
                toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getHourLabels: () => string[];
                getWeekdayLabels: (days: CalendarDay[]) => string[];
                getDayId: (date: Date) => string;
            };
            start: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            end: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            repeat: {
                validated: boolean;
                config: import("../utils/date/repeat").DateRepeatFn | {
                    every?: import("../utils/date/repeat").RepeatIntervalShort | [number, import("../utils/date/repeat").RepeatInterval] | undefined;
                    from?: Date | undefined;
                    until?: Date | undefined;
                    weekdays?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayOfWeek> | undefined;
                    days?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayInMonth> | undefined;
                    weeks?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").WeekInMonth> | undefined;
                    months?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").MonthInYear> | undefined;
                    years?: import("../utils/date/rules").SingleOrArray<number> | undefined;
                    ordinalWeekdays?: import("../utils/date/rules").SingleOrArray<number[]> | undefined;
                    on?: import("../utils/date/repeat").DateRepeatFn | any | (import("../utils/date/repeat").DateRepeatFn | any)[] | undefined;
                };
                type: import("../utils/date/rules").GroupRuleType;
                from: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                until: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                rules: {
                    type: import("../utils/date/rules").RuleType;
                    passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
                }[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                getObjectRules: (config: any) => import("../utils/date/rules").Rule<import("../utils/date/rules").RuleType>[];
                passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            } | null;
            readonly opts: {
                order: number;
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
            };
            readonly hasRepeat: boolean;
            readonly isSingleDay: boolean | null;
            readonly isMultiDay: boolean;
            readonly daySpan: number;
            startsOnDay: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            intersectsDay: (dayIndex: number) => boolean;
            intersectsRange: (range: DateRange) => boolean;
            intersectsDayRange: (startDayIndex: number, endDayIndex: number) => boolean;
        };
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: {
            id?: string | undefined;
            visibility?: import("../utils/popovers").PopoverVisibility | undefined;
            isInteractive?: boolean | undefined;
            autoHide?: boolean | undefined;
            force?: boolean | undefined;
            target?: unknown;
            placement?: import("@popperjs/core").Placement | undefined;
            modifiers?: any;
            data?: any;
            renderFn?: boolean | undefined;
            showDelay?: number | undefined;
            hideDelay?: number | undefined;
        } | null;
        resizeOrigin: {
            start: Date;
            end: Date;
            isStart: boolean;
        } | null;
        dragOrigin: {
            day: {
                id: string;
                position: number;
                label: string;
                ariaLabel: string;
                weekdayPosition: number;
                weekdayPositionFromEnd: number;
                weekPosition: number;
                isoWeeknumber: number;
                startDate: Date;
                noonDate: Date;
                endDate: Date;
                isToday: boolean;
                isFirstDay: boolean;
                isLastDay: boolean;
                isDisabled: boolean;
                isFocusable: boolean;
                inMonth: boolean;
                inPrevMonth: boolean;
                inNextMonth: boolean;
                onTop: boolean;
                onBottom: boolean;
                onLeft: boolean;
                onRight: boolean;
                classes: (string | Object)[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            };
            start: Date;
            end: Date;
            minOffsetWeeks: number;
            maxOffsetWeeks: number;
            minOffsetWeekdays: number;
            maxOffsetWeekdays: number;
            minOffsetMs: number;
            maxOffsetMs: number;
            durationMs: number;
        } | null;
    } | null, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    } | {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: {
            order: number;
            locale: {
                id: any;
                daysInWeek: number;
                firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                masks: any;
                timezone: string | undefined;
                hourLabels: string[];
                dayNames: string[];
                dayNamesShort: string[];
                dayNamesShorter: string[];
                dayNamesNarrow: string[];
                monthNames: string[];
                monthNamesShort: string[];
                relativeTimeNames: {
                    year?: string | undefined;
                    years?: string | undefined;
                    quarter?: string | undefined;
                    quarters?: string | undefined;
                    month?: string | undefined;
                    months?: string | undefined;
                    week?: string | undefined;
                    weeks?: string | undefined;
                    day?: string | undefined;
                    days?: string | undefined;
                    hour?: string | undefined;
                    hours?: string | undefined;
                    minute?: string | undefined;
                    minutes?: string | undefined;
                    second?: string | undefined;
                    seconds?: string | undefined;
                };
                amPm: [string, string];
                monthCache: {
                    keys: string[];
                    store: Record<string, import("../utils/date/helpers").MonthParts>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                };
                pageCache: {
                    keys: string[];
                    store: Record<string, import("../utils/page").CachedPage>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/page").CachedPage;
                    get: (...args: any[]) => import("../utils/page").CachedPage;
                    getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                };
                formatDate: (date: Date, masks: string | string[]) => string;
                parseDate: (dateString: string, mask: string | string[]) => Date;
                toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getHourLabels: () => string[];
                getWeekdayLabels: (days: CalendarDay[]) => string[];
                getDayId: (date: Date) => string;
            };
            start: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            end: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            repeat: {
                validated: boolean;
                config: import("../utils/date/repeat").DateRepeatFn | {
                    every?: import("../utils/date/repeat").RepeatIntervalShort | [number, import("../utils/date/repeat").RepeatInterval] | undefined;
                    from?: Date | undefined;
                    until?: Date | undefined;
                    weekdays?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayOfWeek> | undefined;
                    days?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayInMonth> | undefined;
                    weeks?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").WeekInMonth> | undefined;
                    months?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").MonthInYear> | undefined;
                    years?: import("../utils/date/rules").SingleOrArray<number> | undefined;
                    ordinalWeekdays?: import("../utils/date/rules").SingleOrArray<number[]> | undefined;
                    on?: import("../utils/date/repeat").DateRepeatFn | any | (import("../utils/date/repeat").DateRepeatFn | any)[] | undefined;
                };
                type: import("../utils/date/rules").GroupRuleType;
                from: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                until: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                rules: {
                    type: import("../utils/date/rules").RuleType;
                    passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
                }[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                getObjectRules: (config: any) => import("../utils/date/rules").Rule<import("../utils/date/rules").RuleType>[];
                passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            } | null;
            readonly opts: {
                order: number;
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
            };
            readonly hasRepeat: boolean;
            readonly isSingleDay: boolean | null;
            readonly isMultiDay: boolean;
            readonly daySpan: number;
            startsOnDay: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            intersectsDay: (dayIndex: number) => boolean;
            intersectsRange: (range: DateRange) => boolean;
            intersectsDayRange: (startDayIndex: number, endDayIndex: number) => boolean;
        };
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: {
            id?: string | undefined;
            visibility?: import("../utils/popovers").PopoverVisibility | undefined;
            isInteractive?: boolean | undefined;
            autoHide?: boolean | undefined;
            force?: boolean | undefined;
            target?: unknown;
            placement?: import("@popperjs/core").Placement | undefined;
            modifiers?: any;
            data?: any;
            renderFn?: boolean | undefined;
            showDelay?: number | undefined;
            hideDelay?: number | undefined;
        } | null;
        resizeOrigin: {
            start: Date;
            end: Date;
            isStart: boolean;
        } | null;
        dragOrigin: {
            day: {
                id: string;
                position: number;
                label: string;
                ariaLabel: string;
                weekdayPosition: number;
                weekdayPositionFromEnd: number;
                weekPosition: number;
                isoWeeknumber: number;
                startDate: Date;
                noonDate: Date;
                endDate: Date;
                isToday: boolean;
                isFirstDay: boolean;
                isLastDay: boolean;
                isDisabled: boolean;
                isFocusable: boolean;
                inMonth: boolean;
                inPrevMonth: boolean;
                inNextMonth: boolean;
                onTop: boolean;
                onBottom: boolean;
                onLeft: boolean;
                onRight: boolean;
                classes: (string | Object)[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            };
            start: Date;
            end: Date;
            minOffsetWeeks: number;
            maxOffsetWeeks: number;
            minOffsetWeekdays: number;
            maxOffsetWeekdays: number;
            minOffsetMs: number;
            maxOffsetMs: number;
            durationMs: number;
        } | null;
    } | null>;
    resizing: import("vue").Ref<boolean, boolean>;
    dragging: import("vue").Ref<boolean, boolean>;
    gridStyle: import("vue").ComputedRef<{
        height: string;
    }>;
    fill: import("vue").Ref<string, string>;
    page: import("vue").ComputedRef<import("../utils/page").Page>;
    days: import("vue").ComputedRef<CalendarDay[]>;
    weeks: import("vue").ComputedRef<import("../utils/page").CalendarWeek[]>;
    removeEvent: (event: Event) => void;
    onDayNumberClick(day: CalendarDay): void;
    onGridEscapeKeydown(): void;
    onGridMouseDown(event: MouseEvent): void;
    onEventMouseDown(event: MouseEvent, evt: Event): void;
    onEventResizeStartMouseDown(event: MouseEvent, evt: Event): void;
    onEventResizeEndMouseDown(event: MouseEvent, evt: Event): void;
    onGridTouchStart(event: TouchEvent): void;
    onGridTouchMove(event: TouchEvent): void;
    onGridTouchEnd(event: TouchEvent): void;
    onEventTouchStart(event: TouchEvent, evt: Event): void;
    onEventTouchMove(event: TouchEvent, evt: Event): void;
    onEventTouchEnd(event: TouchEvent, evt: Event): void;
    onEventResizeStartTouchStart(event: TouchEvent, evt: Event): void;
    onEventResizeEndTouchStart(event: TouchEvent, evt: Event): void;
    theme: import("vue").ComputedRef<import("../utils/theme").Theme>;
    color: import("vue").ComputedRef<string>;
    displayMode: import("vue").ComputedRef<"light" | "dark">;
    locale: import("vue").ComputedRef<import("../utils/locale").default>;
    masks: import("vue").ComputedRef<any>;
    attributes: import("vue").ComputedRef<import("../utils/attribute").Attribute[]>;
    disabledAttribute: import("vue").ComputedRef<import("../utils/attribute").Attribute>;
    disabledDates: import("vue").ComputedRef<DateRange[]>;
    attributeContext: import("vue").ComputedRef<DateRangeContext | null>;
    count: import("vue").ComputedRef<number>;
    step: import("vue").ComputedRef<number>;
    firstPage: import("vue").ComputedRef<import("../utils/page").Page | null>;
    lastPage: import("vue").ComputedRef<import("../utils/page").Page | null>;
    canMovePrev: import("vue").ComputedRef<boolean>;
    canMoveNext: import("vue").ComputedRef<boolean>;
    minPage: import("vue").ComputedRef<import("../utils/page").PageAddress | null>;
    maxPage: import("vue").ComputedRef<import("../utils/page").PageAddress | null>;
    isMonthly: import("vue").ComputedRef<boolean>;
    isWeekly: import("vue").ComputedRef<boolean>;
    isDaily: import("vue").ComputedRef<boolean>;
    navVisibility: import("vue").ComputedRef<import("../utils/popovers").PopoverVisibility>;
    showWeeknumbers: import("vue").ComputedRef<boolean>;
    showIsoWeeknumbers: import("vue").ComputedRef<boolean>;
    getDateAddress: (date: import("../utils/date/helpers").DateSource) => import("../utils/page").PageAddress;
    canMove: (target: import("./calendar").MoveTarget, opts?: Partial<import("./calendar").MoveOptions>) => boolean;
    canMoveBy: (pages: number, opts?: Partial<import("./calendar").MoveOptions>) => boolean;
    move: (target: import("./calendar").MoveTarget, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    moveBy: (pages: number, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    movePrev: () => Promise<boolean>;
    moveNext: () => Promise<boolean>;
    onTransitionBeforeEnter: () => void;
    onTransitionAfterEnter: () => void;
    tryFocusDate: (date: Date) => boolean;
    focusDate: (date: Date, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    onKeydown: (event: KeyboardEvent) => void;
    onDayKeydown: (day: CalendarDay, event: KeyboardEvent) => void;
    onDayClick: (day: CalendarDay, event: MouseEvent) => void;
    onDayMouseenter: (day: CalendarDay, event: MouseEvent) => void;
    onDayMouseleave: (day: CalendarDay, event: MouseEvent) => void;
    onDayFocusin: (day: CalendarDay, event: FocusEvent | null) => void;
    onDayFocusout: (day: CalendarDay, event: FocusEvent) => void;
    onWeeknumberClick: (week: import("../utils/page").CalendarWeek, event: MouseEvent) => void;
    containerRef: import("vue").Ref<(Pick<Element, "querySelector"> & import("../utils/helpers").CustomElement) | null, (Pick<Element, "querySelector"> & import("../utils/helpers").CustomElement) | null>;
    navPopoverRef: import("vue").Ref<import("vue").DefineComponent<{}, {}, any, import("vue").ComputedOptions, import("vue").MethodOptions, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | null, import("vue").DefineComponent<{}, {}, any, import("vue").ComputedOptions, import("vue").MethodOptions, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | null>;
    lastFocusedDay: import("vue").Ref<CalendarDay | null, CalendarDay | null>;
    focusableDay: import("vue").Ref<number, number>;
    inTransition: import("vue").Ref<boolean, boolean>;
    navPopoverId: import("vue").Ref<string, string>;
    dayPopoverId: import("vue").Ref<string, string>;
    view: import("vue").Ref<import("./calendar").CalendarView, import("./calendar").CalendarView>;
    pages: import("vue").Ref<import("../utils/page").Page[], import("../utils/page").Page[]>;
    transitionName: import("vue").Ref<string, string>;
    refreshing: import("vue").Ref<boolean, boolean>;
    emit: any;
    slots: any;
};
export declare function useCalendarGrid(): {
    dailyGridRef: import("vue").Ref<{
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null, IBoundingRect | {
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null>;
    weeklyGridRef: import("vue").Ref<{
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null, IBoundingRect | {
        getBoundingClientRect: () => DOMRect;
        contains: (other: Node | null) => boolean;
    } | null>;
    cellPopoverRef: import("vue").Ref<import("vue").DefineComponent<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>, {
        displayMode: import("vue").ComputedRef<"light" | "dark">;
        color: import("vue").ComputedRef<string>;
        show: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        update: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        hide: () => void;
        isVisible: () => boolean;
        onAfterHide(): void;
        event: import("vue").Ref<{
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null, {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null>;
        popoverRef: import("vue").Ref<null, null>;
    }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>> & Readonly<{}>, {
        popoverId: string;
    }, {}, {
        Popover: import("vue").DefineComponent<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>, {
            popoverRef: import("vue").Ref<HTMLElement | undefined, HTMLElement | undefined>;
            alignment: import("vue").ComputedRef<"center" | "left" | "right" | "top" | "bottom" | "middle">;
            hide: (opts?: Partial<import("../utils/popovers").PopoverOptions>) => void;
            setupPopper: () => void;
            beforeEnter: (el: HTMLElement) => void;
            afterEnter: (el: HTMLElement) => void;
            beforeLeave: (el: HTMLElement) => void;
            afterLeave: (el: HTMLElement) => void;
            onClick: (e: MouseEvent) => void;
            onMouseOver: () => void;
            onMouseLeave: () => void;
            onFocusIn: () => void;
            onFocusOut: (e: FocusEvent) => void;
            isVisible: import("vue").Ref<boolean, boolean>;
            target: import("vue").Ref<unknown, unknown>;
            data: import("vue").Ref<any, any>;
            transition: import("vue").Ref<string, string>;
            placement: import("vue").Ref<import("@popperjs/core").Placement, import("@popperjs/core").Placement>;
            direction: import("vue").Ref<string, string>;
            positionFixed: import("vue").Ref<false, false>;
            modifiers: import("vue").Ref<any[], any[]>;
            isInteractive: import("vue").Ref<boolean, boolean>;
            visibility: import("vue").Ref<import("../utils/popovers").PopoverVisibility, import("../utils/popovers").PopoverVisibility>;
            isHovered: import("vue").Ref<boolean, boolean>;
            isFocused: import("vue").Ref<boolean, boolean>;
            autoHide: import("vue").Ref<boolean, boolean>;
            force: import("vue").Ref<boolean, boolean>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("before-show" | "after-show" | "before-hide" | "after-hide")[], "before-show" | "after-show" | "before-hide" | "after-hide", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>> & Readonly<{
            "onBefore-show"?: ((...args: any[]) => any) | undefined;
            "onAfter-show"?: ((...args: any[]) => any) | undefined;
            "onBefore-hide"?: ((...args: any[]) => any) | undefined;
            "onAfter-hide"?: ((...args: any[]) => any) | undefined;
        }>, {
            showDelay: number;
            hideDelay: number;
        }, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
        CalendarEventEdit: import("vue").DefineComponent<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>, {
            onRemove(): void;
            onToggleEditing(): void;
            onSave(): void;
            onCancel(): void;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "close"[], "close", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>> & Readonly<{
            onClose?: ((...args: any[]) => any) | undefined;
        }>, {}, {}, {}, {
            focus: {
                mounted(el: any): void;
            };
        }, string, import("vue").ComponentProvideOptions, true, {}, any>;
    }, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | undefined, import("vue").DefineComponent<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>, {
        displayMode: import("vue").ComputedRef<"light" | "dark">;
        color: import("vue").ComputedRef<string>;
        show: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        update: (event: {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        }) => void;
        hide: () => void;
        isVisible: () => boolean;
        onAfterHide(): void;
        event: import("vue").Ref<{
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null, {
            refSelector: string;
            isMultiDay: boolean;
            isWeekly: boolean;
            durationMs: number;
            durationMinutes: number;
            startDate: Date;
            startDateTime: number;
            startTimeLabel: string;
            endDate: Date;
            endDateTime: number;
            endTimeLabel: string;
            timeLabel: string;
            isSolid: boolean;
            dragIsDirty: boolean;
            formatDate: (date: Date, mask: string) => string;
            formatTime: (date: Date) => string;
            resizeToConstraints: () => void;
            startResize: (day: CalendarDay, isStart: boolean) => void;
            updateResize: (offset: ResizeOffset) => void;
            stopResize: () => void;
            startDrag: (day: CalendarDay) => void;
            updateDrag: (offset: DragOffset) => void;
            stopDrag: () => false | undefined;
            compareTo: (b: any) => number;
            key: any;
            summary: string;
            description: string;
            range: DateRange;
            allDay: boolean;
            color: string;
            fill: string;
            selected: boolean;
            draggable: boolean;
            dragging: boolean;
            resizable: boolean;
            resizing: boolean;
            editing: boolean;
            order: number;
            snapMinutes: number;
            minDurationMinutes: number;
            maxDurationMinutes: number;
            popover: Partial<import("../utils/popovers").PopoverOptions> | null;
            resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
            dragOrigin: import("../utils/calendar/event").DragOrigin | null;
        } | null>;
        popoverRef: import("vue").Ref<null, null>;
    }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{
        popoverId: {
            type: StringConstructor;
            default: string;
        };
    }>> & Readonly<{}>, {
        popoverId: string;
    }, {}, {
        Popover: import("vue").DefineComponent<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>, {
            popoverRef: import("vue").Ref<HTMLElement | undefined, HTMLElement | undefined>;
            alignment: import("vue").ComputedRef<"center" | "left" | "right" | "top" | "bottom" | "middle">;
            hide: (opts?: Partial<import("../utils/popovers").PopoverOptions>) => void;
            setupPopper: () => void;
            beforeEnter: (el: HTMLElement) => void;
            afterEnter: (el: HTMLElement) => void;
            beforeLeave: (el: HTMLElement) => void;
            afterLeave: (el: HTMLElement) => void;
            onClick: (e: MouseEvent) => void;
            onMouseOver: () => void;
            onMouseLeave: () => void;
            onFocusIn: () => void;
            onFocusOut: (e: FocusEvent) => void;
            isVisible: import("vue").Ref<boolean, boolean>;
            target: import("vue").Ref<unknown, unknown>;
            data: import("vue").Ref<any, any>;
            transition: import("vue").Ref<string, string>;
            placement: import("vue").Ref<import("@popperjs/core").Placement, import("@popperjs/core").Placement>;
            direction: import("vue").Ref<string, string>;
            positionFixed: import("vue").Ref<false, false>;
            modifiers: import("vue").Ref<any[], any[]>;
            isInteractive: import("vue").Ref<boolean, boolean>;
            visibility: import("vue").Ref<import("../utils/popovers").PopoverVisibility, import("../utils/popovers").PopoverVisibility>;
            isHovered: import("vue").Ref<boolean, boolean>;
            isFocused: import("vue").Ref<boolean, boolean>;
            autoHide: import("vue").Ref<boolean, boolean>;
            force: import("vue").Ref<boolean, boolean>;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, ("before-show" | "after-show" | "before-hide" | "after-hide")[], "before-show" | "after-show" | "before-hide" | "after-hide", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            id: {
                type: StringConstructor;
                required: true;
            };
            showDelay: {
                type: NumberConstructor;
                default: number;
            };
            hideDelay: {
                type: NumberConstructor;
                default: number;
            };
            boundarySelector: {
                type: StringConstructor;
            };
        }>> & Readonly<{
            "onBefore-show"?: ((...args: any[]) => any) | undefined;
            "onAfter-show"?: ((...args: any[]) => any) | undefined;
            "onBefore-hide"?: ((...args: any[]) => any) | undefined;
            "onAfter-hide"?: ((...args: any[]) => any) | undefined;
        }>, {
            showDelay: number;
            hideDelay: number;
        }, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any>;
        CalendarEventEdit: import("vue").DefineComponent<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>, {
            onRemove(): void;
            onToggleEditing(): void;
            onSave(): void;
            onCancel(): void;
        }, {}, {}, {}, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, "close"[], "close", import("vue").PublicProps, Readonly<ExtractPropTypes<{
            event: {
                type: PropType<{
                    refSelector: string;
                    isMultiDay: boolean;
                    isWeekly: boolean;
                    durationMs: number;
                    durationMinutes: number;
                    startDate: Date;
                    startDateTime: number;
                    startTimeLabel: string;
                    endDate: Date;
                    endDateTime: number;
                    endTimeLabel: string;
                    timeLabel: string;
                    isSolid: boolean;
                    dragIsDirty: boolean;
                    formatDate: (date: Date, mask: string) => string;
                    formatTime: (date: Date) => string;
                    resizeToConstraints: () => void;
                    startResize: (day: CalendarDay, isStart: boolean) => void;
                    updateResize: (offset: ResizeOffset) => void;
                    stopResize: () => void;
                    startDrag: (day: CalendarDay) => void;
                    updateDrag: (offset: DragOffset) => void;
                    stopDrag: () => false | undefined;
                    compareTo: (b: any) => number;
                    key: any;
                    summary: string;
                    description: string;
                    range: DateRange;
                    allDay: boolean;
                    color: string;
                    fill: string;
                    selected: boolean;
                    draggable: boolean;
                    dragging: boolean;
                    resizable: boolean;
                    resizing: boolean;
                    editing: boolean;
                    order: number;
                    snapMinutes: number;
                    minDurationMinutes: number;
                    maxDurationMinutes: number;
                    popover: Partial<import("../utils/popovers").PopoverOptions> | null;
                    resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
                    dragOrigin: import("../utils/calendar/event").DragOrigin | null;
                }>;
                required: true;
            };
        }>> & Readonly<{
            onClose?: ((...args: any[]) => any) | undefined;
        }>, {}, {}, {}, {
            focus: {
                mounted(el: any): void;
            };
        }, string, import("vue").ComponentProvideOptions, true, {}, any>;
    }, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | undefined>;
    dayColumns: import("vue").ComputedRef<number>;
    dayRows: import("vue").ComputedRef<number>;
    snapMinutes: import("vue").Ref<number, number>;
    snapMs: import("vue").ComputedRef<number>;
    pixelsPerHour: import("vue").Ref<number, number>;
    isTouch: import("vue").Ref<boolean, boolean>;
    events: import("vue").ComputedRef<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }[]>;
    eventsMap: import("vue").Ref<Record<any, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }>, Record<any, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }>>;
    selectedEvents: import("vue").ComputedRef<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }[]>;
    hasSelectedEvents: import("vue").ComputedRef<boolean>;
    eventsContext: import("vue").ComputedRef<DateRangeContext>;
    detailEvent: import("vue").Ref<{
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: {
            order: number;
            locale: {
                id: any;
                daysInWeek: number;
                firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                masks: any;
                timezone: string | undefined;
                hourLabels: string[];
                dayNames: string[];
                dayNamesShort: string[];
                dayNamesShorter: string[];
                dayNamesNarrow: string[];
                monthNames: string[];
                monthNamesShort: string[];
                relativeTimeNames: {
                    year?: string | undefined;
                    years?: string | undefined;
                    quarter?: string | undefined;
                    quarters?: string | undefined;
                    month?: string | undefined;
                    months?: string | undefined;
                    week?: string | undefined;
                    weeks?: string | undefined;
                    day?: string | undefined;
                    days?: string | undefined;
                    hour?: string | undefined;
                    hours?: string | undefined;
                    minute?: string | undefined;
                    minutes?: string | undefined;
                    second?: string | undefined;
                    seconds?: string | undefined;
                };
                amPm: [string, string];
                monthCache: {
                    keys: string[];
                    store: Record<string, import("../utils/date/helpers").MonthParts>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                };
                pageCache: {
                    keys: string[];
                    store: Record<string, import("../utils/page").CachedPage>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/page").CachedPage;
                    get: (...args: any[]) => import("../utils/page").CachedPage;
                    getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                };
                formatDate: (date: Date, masks: string | string[]) => string;
                parseDate: (dateString: string, mask: string | string[]) => Date;
                toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getHourLabels: () => string[];
                getWeekdayLabels: (days: CalendarDay[]) => string[];
                getDayId: (date: Date) => string;
            };
            start: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            end: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            repeat: {
                validated: boolean;
                config: import("../utils/date/repeat").DateRepeatFn | {
                    every?: import("../utils/date/repeat").RepeatIntervalShort | [number, import("../utils/date/repeat").RepeatInterval] | undefined;
                    from?: Date | undefined;
                    until?: Date | undefined;
                    weekdays?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayOfWeek> | undefined;
                    days?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayInMonth> | undefined;
                    weeks?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").WeekInMonth> | undefined;
                    months?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").MonthInYear> | undefined;
                    years?: import("../utils/date/rules").SingleOrArray<number> | undefined;
                    ordinalWeekdays?: import("../utils/date/rules").SingleOrArray<number[]> | undefined;
                    on?: import("../utils/date/repeat").DateRepeatFn | any | (import("../utils/date/repeat").DateRepeatFn | any)[] | undefined;
                };
                type: import("../utils/date/rules").GroupRuleType;
                from: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                until: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                rules: {
                    type: import("../utils/date/rules").RuleType;
                    passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
                }[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                getObjectRules: (config: any) => import("../utils/date/rules").Rule<import("../utils/date/rules").RuleType>[];
                passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            } | null;
            readonly opts: {
                order: number;
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
            };
            readonly hasRepeat: boolean;
            readonly isSingleDay: boolean | null;
            readonly isMultiDay: boolean;
            readonly daySpan: number;
            startsOnDay: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            intersectsDay: (dayIndex: number) => boolean;
            intersectsRange: (range: DateRange) => boolean;
            intersectsDayRange: (startDayIndex: number, endDayIndex: number) => boolean;
        };
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: {
            id?: string | undefined;
            visibility?: import("../utils/popovers").PopoverVisibility | undefined;
            isInteractive?: boolean | undefined;
            autoHide?: boolean | undefined;
            force?: boolean | undefined;
            target?: unknown;
            placement?: import("@popperjs/core").Placement | undefined;
            modifiers?: any;
            data?: any;
            renderFn?: boolean | undefined;
            showDelay?: number | undefined;
            hideDelay?: number | undefined;
        } | null;
        resizeOrigin: {
            start: Date;
            end: Date;
            isStart: boolean;
        } | null;
        dragOrigin: {
            day: {
                id: string;
                position: number;
                label: string;
                ariaLabel: string;
                weekdayPosition: number;
                weekdayPositionFromEnd: number;
                weekPosition: number;
                isoWeeknumber: number;
                startDate: Date;
                noonDate: Date;
                endDate: Date;
                isToday: boolean;
                isFirstDay: boolean;
                isLastDay: boolean;
                isDisabled: boolean;
                isFocusable: boolean;
                inMonth: boolean;
                inPrevMonth: boolean;
                inNextMonth: boolean;
                onTop: boolean;
                onBottom: boolean;
                onLeft: boolean;
                onRight: boolean;
                classes: (string | Object)[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            };
            start: Date;
            end: Date;
            minOffsetWeeks: number;
            maxOffsetWeeks: number;
            minOffsetWeekdays: number;
            maxOffsetWeekdays: number;
            minOffsetMs: number;
            maxOffsetMs: number;
            durationMs: number;
        } | null;
    } | null, {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    } | {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: {
            order: number;
            locale: {
                id: any;
                daysInWeek: number;
                firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                masks: any;
                timezone: string | undefined;
                hourLabels: string[];
                dayNames: string[];
                dayNamesShort: string[];
                dayNamesShorter: string[];
                dayNamesNarrow: string[];
                monthNames: string[];
                monthNamesShort: string[];
                relativeTimeNames: {
                    year?: string | undefined;
                    years?: string | undefined;
                    quarter?: string | undefined;
                    quarters?: string | undefined;
                    month?: string | undefined;
                    months?: string | undefined;
                    week?: string | undefined;
                    weeks?: string | undefined;
                    day?: string | undefined;
                    days?: string | undefined;
                    hour?: string | undefined;
                    hours?: string | undefined;
                    minute?: string | undefined;
                    minutes?: string | undefined;
                    second?: string | undefined;
                    seconds?: string | undefined;
                };
                amPm: [string, string];
                monthCache: {
                    keys: string[];
                    store: Record<string, import("../utils/date/helpers").MonthParts>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                };
                pageCache: {
                    keys: string[];
                    store: Record<string, import("../utils/page").CachedPage>;
                    size: number;
                    createKey: (...args: any[]) => string;
                    createItem: (...args: any[]) => import("../utils/page").CachedPage;
                    get: (...args: any[]) => import("../utils/page").CachedPage;
                    getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                };
                formatDate: (date: Date, masks: string | string[]) => string;
                parseDate: (dateString: string, mask: string | string[]) => Date;
                toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                getHourLabels: () => string[];
                getWeekdayLabels: (days: CalendarDay[]) => string[];
                getDayId: (date: Date) => string;
            };
            start: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            end: {
                milliseconds: number;
                seconds: number;
                minutes: number;
                hours: number;
                time: number;
                dateTime: number;
                isValid: boolean;
                timezoneOffset: number;
                isPm?: boolean | undefined;
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            } | null;
            repeat: {
                validated: boolean;
                config: import("../utils/date/repeat").DateRepeatFn | {
                    every?: import("../utils/date/repeat").RepeatIntervalShort | [number, import("../utils/date/repeat").RepeatInterval] | undefined;
                    from?: Date | undefined;
                    until?: Date | undefined;
                    weekdays?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayOfWeek> | undefined;
                    days?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").DayInMonth> | undefined;
                    weeks?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").WeekInMonth> | undefined;
                    months?: import("../utils/date/rules").SingleOrArray<import("../utils/date/helpers").MonthInYear> | undefined;
                    years?: import("../utils/date/rules").SingleOrArray<number> | undefined;
                    ordinalWeekdays?: import("../utils/date/rules").SingleOrArray<number[]> | undefined;
                    on?: import("../utils/date/repeat").DateRepeatFn | any | (import("../utils/date/repeat").DateRepeatFn | any)[] | undefined;
                };
                type: import("../utils/date/rules").GroupRuleType;
                from: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                until: {
                    milliseconds: number;
                    seconds: number;
                    minutes: number;
                    hours: number;
                    time: number;
                    dateTime: number;
                    isValid: boolean;
                    timezoneOffset: number;
                    isPm?: boolean | undefined;
                    dayIndex: number;
                    day: number;
                    dayFromEnd: number;
                    weekday: number;
                    weekdayOrdinal: number;
                    weekdayOrdinalFromEnd: number;
                    week: number;
                    weekFromEnd: number;
                    weeknumber: number;
                    month: number;
                    year: number;
                    date: Date;
                } | undefined;
                rules: {
                    type: import("../utils/date/rules").RuleType;
                    passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
                }[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                getObjectRules: (config: any) => import("../utils/date/rules").Rule<import("../utils/date/rules").RuleType>[];
                passes: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            } | null;
            readonly opts: {
                order: number;
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
            };
            readonly hasRepeat: boolean;
            readonly isSingleDay: boolean | null;
            readonly isMultiDay: boolean;
            readonly daySpan: number;
            startsOnDay: (dayParts: import("../utils/date/helpers").DayParts) => boolean;
            intersectsDay: (dayIndex: number) => boolean;
            intersectsRange: (range: DateRange) => boolean;
            intersectsDayRange: (startDayIndex: number, endDayIndex: number) => boolean;
        };
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: {
            id?: string | undefined;
            visibility?: import("../utils/popovers").PopoverVisibility | undefined;
            isInteractive?: boolean | undefined;
            autoHide?: boolean | undefined;
            force?: boolean | undefined;
            target?: unknown;
            placement?: import("@popperjs/core").Placement | undefined;
            modifiers?: any;
            data?: any;
            renderFn?: boolean | undefined;
            showDelay?: number | undefined;
            hideDelay?: number | undefined;
        } | null;
        resizeOrigin: {
            start: Date;
            end: Date;
            isStart: boolean;
        } | null;
        dragOrigin: {
            day: {
                id: string;
                position: number;
                label: string;
                ariaLabel: string;
                weekdayPosition: number;
                weekdayPositionFromEnd: number;
                weekPosition: number;
                isoWeeknumber: number;
                startDate: Date;
                noonDate: Date;
                endDate: Date;
                isToday: boolean;
                isFirstDay: boolean;
                isLastDay: boolean;
                isDisabled: boolean;
                isFocusable: boolean;
                inMonth: boolean;
                inPrevMonth: boolean;
                inNextMonth: boolean;
                onTop: boolean;
                onBottom: boolean;
                onLeft: boolean;
                onRight: boolean;
                classes: (string | Object)[];
                locale: {
                    id: any;
                    daysInWeek: number;
                    firstDayOfWeek: import("../utils/date/helpers").DayOfWeek;
                    masks: any;
                    timezone: string | undefined;
                    hourLabels: string[];
                    dayNames: string[];
                    dayNamesShort: string[];
                    dayNamesShorter: string[];
                    dayNamesNarrow: string[];
                    monthNames: string[];
                    monthNamesShort: string[];
                    relativeTimeNames: {
                        year?: string | undefined;
                        years?: string | undefined;
                        quarter?: string | undefined;
                        quarters?: string | undefined;
                        month?: string | undefined;
                        months?: string | undefined;
                        week?: string | undefined;
                        weeks?: string | undefined;
                        day?: string | undefined;
                        days?: string | undefined;
                        hour?: string | undefined;
                        hours?: string | undefined;
                        minute?: string | undefined;
                        minutes?: string | undefined;
                        second?: string | undefined;
                        seconds?: string | undefined;
                    };
                    amPm: [string, string];
                    monthCache: {
                        keys: string[];
                        store: Record<string, import("../utils/date/helpers").MonthParts>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        get: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                        getOrSet: (...args: any[]) => import("../utils/date/helpers").MonthParts;
                    };
                    pageCache: {
                        keys: string[];
                        store: Record<string, import("../utils/page").CachedPage>;
                        size: number;
                        createKey: (...args: any[]) => string;
                        createItem: (...args: any[]) => import("../utils/page").CachedPage;
                        get: (...args: any[]) => import("../utils/page").CachedPage;
                        getOrSet: (...args: any[]) => import("../utils/page").CachedPage;
                    };
                    formatDate: (date: Date, masks: string | string[]) => string;
                    parseDate: (dateString: string, mask: string | string[]) => Date;
                    toDate: (d: import("../utils/date/helpers").DateSource | Partial<import("../utils/date/helpers").SimpleDateParts>, opts?: Partial<import("../utils/date/helpers").DateOptions>) => Date;
                    fromDate: (date: Date, { type, mask }?: Partial<import("../utils/date/helpers").DateOptions>) => string | number | Date | import("../utils/date/helpers").DateParts | null;
                    range: (source: import("../utils/date/range").DateRangeSource) => DateRange;
                    ranges: (ranges: import("../utils/date/range").DateRangeSource | import("../utils/date/range").DateRangeSource[]) => DateRange[];
                    getDateParts: (date: Date) => import("../utils/date/helpers").DateParts;
                    getDateFromParts: (parts: Partial<import("../utils/date/helpers").SimpleDateParts>) => Date;
                    getDateFromParams: (year: number, month: number, day: number, hours: number, minutes: number, seconds: number, milliseconds: number) => Date;
                    getPage: (config: import("../utils/page").PageConfig) => import("../utils/page").Page;
                    getMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getThisMonthParts: () => import("../utils/date/helpers").MonthParts;
                    getPrevMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getNextMonthParts: (month: number, year: number) => import("../utils/date/helpers").MonthParts;
                    getHourLabels: () => string[];
                    getWeekdayLabels: (days: CalendarDay[]) => string[];
                    getDayId: (date: Date) => string;
                };
                dayIndex: number;
                day: number;
                dayFromEnd: number;
                weekday: number;
                weekdayOrdinal: number;
                weekdayOrdinalFromEnd: number;
                week: number;
                weekFromEnd: number;
                weeknumber: number;
                month: number;
                year: number;
                date: Date;
            };
            start: Date;
            end: Date;
            minOffsetWeeks: number;
            maxOffsetWeeks: number;
            minOffsetWeekdays: number;
            maxOffsetWeekdays: number;
            minOffsetMs: number;
            maxOffsetMs: number;
            durationMs: number;
        } | null;
    } | null>;
    resizing: import("vue").Ref<boolean, boolean>;
    dragging: import("vue").Ref<boolean, boolean>;
    gridStyle: import("vue").ComputedRef<{
        height: string;
    }>;
    fill: import("vue").Ref<string, string>;
    page: import("vue").ComputedRef<import("../utils/page").Page>;
    days: import("vue").ComputedRef<CalendarDay[]>;
    weeks: import("vue").ComputedRef<import("../utils/page").CalendarWeek[]>;
    removeEvent: (event: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }) => void;
    onDayNumberClick(day: CalendarDay): void;
    onGridEscapeKeydown(): void;
    onGridMouseDown(event: MouseEvent): void;
    onEventMouseDown(event: MouseEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventResizeStartMouseDown(event: MouseEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventResizeEndMouseDown(event: MouseEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onGridTouchStart(event: TouchEvent): void;
    onGridTouchMove(event: TouchEvent): void;
    onGridTouchEnd(event: TouchEvent): void;
    onEventTouchStart(event: TouchEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventTouchMove(event: TouchEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventTouchEnd(event: TouchEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventResizeStartTouchStart(event: TouchEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    onEventResizeEndTouchStart(event: TouchEvent, evt: {
        refSelector: string;
        isMultiDay: boolean;
        isWeekly: boolean;
        durationMs: number;
        durationMinutes: number;
        startDate: Date;
        startDateTime: number;
        startTimeLabel: string;
        endDate: Date;
        endDateTime: number;
        endTimeLabel: string;
        timeLabel: string;
        isSolid: boolean;
        dragIsDirty: boolean;
        formatDate: (date: Date, mask: string) => string;
        formatTime: (date: Date) => string;
        resizeToConstraints: () => void;
        startResize: (day: CalendarDay, isStart: boolean) => void;
        updateResize: (offset: ResizeOffset) => void;
        stopResize: () => void;
        startDrag: (day: CalendarDay) => void;
        updateDrag: (offset: DragOffset) => void;
        stopDrag: () => false | undefined;
        compareTo: (b: any) => number;
        key: any;
        summary: string;
        description: string;
        range: DateRange;
        allDay: boolean;
        color: string;
        fill: string;
        selected: boolean;
        draggable: boolean;
        dragging: boolean;
        resizable: boolean;
        resizing: boolean;
        editing: boolean;
        order: number;
        snapMinutes: number;
        minDurationMinutes: number;
        maxDurationMinutes: number;
        popover: Partial<import("../utils/popovers").PopoverOptions> | null;
        resizeOrigin: import("../utils/calendar/event").ResizeOrigin | null;
        dragOrigin: import("../utils/calendar/event").DragOrigin | null;
    }): void;
    theme: import("vue").ComputedRef<import("../utils/theme").Theme>;
    color: import("vue").ComputedRef<string>;
    displayMode: import("vue").ComputedRef<"light" | "dark">;
    locale: import("vue").ComputedRef<import("../utils/locale").default>;
    masks: import("vue").ComputedRef<any>;
    attributes: import("vue").ComputedRef<import("../utils/attribute").Attribute[]>;
    disabledAttribute: import("vue").ComputedRef<import("../utils/attribute").Attribute>;
    disabledDates: import("vue").ComputedRef<DateRange[]>;
    attributeContext: import("vue").ComputedRef<DateRangeContext | null>;
    count: import("vue").ComputedRef<number>;
    step: import("vue").ComputedRef<number>;
    firstPage: import("vue").ComputedRef<import("../utils/page").Page | null>;
    lastPage: import("vue").ComputedRef<import("../utils/page").Page | null>;
    canMovePrev: import("vue").ComputedRef<boolean>;
    canMoveNext: import("vue").ComputedRef<boolean>;
    minPage: import("vue").ComputedRef<import("../utils/page").PageAddress | null>;
    maxPage: import("vue").ComputedRef<import("../utils/page").PageAddress | null>;
    isMonthly: import("vue").ComputedRef<boolean>;
    isWeekly: import("vue").ComputedRef<boolean>;
    isDaily: import("vue").ComputedRef<boolean>;
    navVisibility: import("vue").ComputedRef<import("../utils/popovers").PopoverVisibility>;
    showWeeknumbers: import("vue").ComputedRef<boolean>;
    showIsoWeeknumbers: import("vue").ComputedRef<boolean>;
    getDateAddress: (date: import("../utils/date/helpers").DateSource) => import("../utils/page").PageAddress;
    canMove: (target: import("./calendar").MoveTarget, opts?: Partial<import("./calendar").MoveOptions>) => boolean;
    canMoveBy: (pages: number, opts?: Partial<import("./calendar").MoveOptions>) => boolean;
    move: (target: import("./calendar").MoveTarget, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    moveBy: (pages: number, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    movePrev: () => Promise<boolean>;
    moveNext: () => Promise<boolean>;
    onTransitionBeforeEnter: () => void;
    onTransitionAfterEnter: () => void;
    tryFocusDate: (date: Date) => boolean;
    focusDate: (date: Date, opts?: Partial<import("./calendar").MoveOptions>) => Promise<boolean>;
    onKeydown: (event: KeyboardEvent) => void;
    onDayKeydown: (day: CalendarDay, event: KeyboardEvent) => void;
    onDayClick: (day: CalendarDay, event: MouseEvent) => void;
    onDayMouseenter: (day: CalendarDay, event: MouseEvent) => void;
    onDayMouseleave: (day: CalendarDay, event: MouseEvent) => void;
    onDayFocusin: (day: CalendarDay, event: FocusEvent | null) => void;
    onDayFocusout: (day: CalendarDay, event: FocusEvent) => void;
    onWeeknumberClick: (week: import("../utils/page").CalendarWeek, event: MouseEvent) => void;
    containerRef: import("vue").Ref<(Pick<Element, "querySelector"> & import("../utils/helpers").CustomElement) | null, (Pick<Element, "querySelector"> & import("../utils/helpers").CustomElement) | null>;
    navPopoverRef: import("vue").Ref<import("vue").DefineComponent<{}, {}, any, import("vue").ComputedOptions, import("vue").MethodOptions, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | null, import("vue").DefineComponent<{}, {}, any, import("vue").ComputedOptions, import("vue").MethodOptions, import("vue").ComponentOptionsMixin, import("vue").ComponentOptionsMixin, {}, string, import("vue").PublicProps, Readonly<ExtractPropTypes<{}>>, {}, {}, {}, {}, string, import("vue").ComponentProvideOptions, true, {}, any> | null>;
    lastFocusedDay: import("vue").Ref<CalendarDay | null, CalendarDay | null>;
    focusableDay: import("vue").Ref<number, number>;
    inTransition: import("vue").Ref<boolean, boolean>;
    navPopoverId: import("vue").Ref<string, string>;
    dayPopoverId: import("vue").Ref<string, string>;
    view: import("vue").Ref<import("./calendar").CalendarView, import("./calendar").CalendarView>;
    pages: import("vue").Ref<import("../utils/page").Page[], import("../utils/page").Page[]>;
    transitionName: import("vue").Ref<string, string>;
    refreshing: import("vue").Ref<boolean, boolean>;
    emit: any;
    slots: any;
};
export {};
